import oqs

def create_signature(algorithm: str, message: bytes, private_key: bytes) -> bytes:
    with oqs.Signature(algorithm, secret_key=private_key) as signer:
        return signer.sign(message) 

def verify_signature(algorithm: str, message: bytes, signature: bytes, public_key: bytes) -> bool:
    with oqs.Signature(algorithm) as verifier:
        return verifier.verify(message, signature, public_key)

def generate_sign_keys(algorithm: str = "Dilithium5"): 
    with oqs.Signature(algorithm) as signer:
        public_key = signer.generate_keypair()
        private_key = signer.export_secret_key()
        return private_key, public_key



def one_time_pad(plain_text: bytes, key: bytes) -> bytes:
    """
        Does one-time-pad XOR encryption on plain_text with key and returns result

        OTP is the only known encryption system that is mathematically proven to be unbreakable under the principles of information theory
        if the key is random and never reused
    """
    otpd_plain_text = b''
    for index, plain_byte in enumerate(plain_text):
        key_byte = key[index]
        otpd_plain_text += bytes([plain_byte ^ key_byte])

    return otpd_plain_text



def generate_kem_keys(algorithm: str = "Kyber1024"):
    with oqs.KeyEncapsulation(algorithm) as kem:
        public_key = kem.generate_keypair()
        private_key = kem.export_secret_key()
        return private_key, public_key


def decrypt_kyber_shared_secrets(ciphertext_blob: bytes, private_key: bytes, otp_pad_size: int = 10240, algorithm: str = "Kyber1024"):
    """
        Decapsulates shared_secrets of size otp_pad_size and returns the resulting shared_secrets.
        The ciphertexts_blob is expected to be a concatenated sequence of Kyber ciphertexts,
        originally generated by generate_kyber_shared_secrets and sent by the contact.

        The shared_secrets are meant to be used as one-time-pads to decrypt received messages.

        Kyber1024 has a defined fixed-size ciphertext of 1568 bytes each, which allows us to safely
        split the blob and decapsulate in order.
    """

    shared_secrets = b''
    cipher_size = 1568  # Kyber1024 ciphertext size
    cursor = 0

    with oqs.KeyEncapsulation(algorithm, secret_key=private_key) as kem:
        while len(shared_secrets) < otp_pad_size:
            ciphertext = ciphertext_blob[cursor:cursor + cipher_size]

            if len(ciphertext) != cipher_size:
                raise ValueError("Ciphertext blob is malformed or incomplete")

            shared_secret = kem.decap_secret(ciphertext)
            shared_secrets += shared_secret
            cursor += cipher_size

    return shared_secrets[:otp_pad_size]

def generate_kyber_shared_secrets(public_key: bytes, otp_pad_size: int = 10240, algorithm: str = "Kyber1024"):
    """
        Generates shared_secrets of size otp_pad_size and returns both the ciphertext list-
        and the generated shared_secrets.
        The shared_secrets are meant to be used as one-time-pads to encypt our messages,
        while the ciphertext is meant to be sent to the contact.


        Default desired One-time-pad size is set to 10 kilobytes which is meant to accommodate-
        10 messages, assuming every message is 1024 bytes.


        We concatenate the ciphertexts together safely because Kyper1024 has a defined fixed-size ciphertext-
        of 1568 bytes each.
    """

    shared_secrets   = b''
    ciphertexts_blob = b''

    with oqs.KeyEncapsulation(algorithm) as kem:
        while len(shared_secrets) < otp_pad_size:
            ciphertext, shared_secret = kem.encap_secret(public_key)

            ciphertexts_blob += ciphertext
            shared_secrets   += shared_secret

    return ciphertexts_blob, shared_secrets[:otp_pad_size]


