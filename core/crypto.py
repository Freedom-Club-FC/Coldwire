from core.constants import *
import oqs
import secrets

def create_signature(algorithm: str, message: bytes, private_key: bytes) -> bytes:
    with oqs.Signature(algorithm, secret_key=private_key) as signer:
        return signer.sign(message) 

def verify_signature(algorithm: str, message: bytes, signature: bytes, public_key: bytes) -> bool:
    with oqs.Signature(algorithm) as verifier:
        return verifier.verify(message, signature, public_key)

def generate_sign_keys(algorithm: str = "Dilithium5"): 
    with oqs.Signature(algorithm) as signer:
        public_key = signer.generate_keypair()
        private_key = signer.export_secret_key()
        return private_key, public_key


def otp_encrypt_with_padding(plaintext: bytes, key: bytes, padding_limit: int) -> bytes:
    """
        Encrypts a plaintext with a one-time pad with padding.

        - Always prefixes the plaintext with a OTP_PADDING_LENGTH big-endian length.
        - Pads with random bytes up to padding_limit, if padding_limit is 0
        - Then no padding is added

        Args:
            plaintext: The plaintext message to encrypt.
            key: The one-time pad. Must be at least as long as the plaintext block.
            padding_limit: The padding limit

        Returns:
            Ciphertext as bytes.

    """

    if padding_limit > ((2 ** (8 * OTP_PADDING_LENGTH)) - 1):
        raise ValueError("Padding too large")

    # NOTE: If padding_limit is 0, the plaintext_paddding_bytes would also be 0
    # Which means an attacker could potentially learn some info the first 2 bytes
    # which consists of the padding_length. This is fine as OTP security guarantees
    # as long as the rest of key is random and never reused, the security 
    # wouldn't be affected at all.
    #
    # However, this could aid the adversary to confidently recover message length 
    # as he now knows that the padding is 0 and hence could calculate the length 
    # of the plaintext.
    # This can be prevented if padding_limit is randomized even just slightly
    # We leave that responsibility to the caller

    plaintext_padding = secrets.token_bytes(padding_limit)
    padding_length_bytes = len(plaintext_padding).to_bytes(OTP_PADDING_LENGTH, "big")

    padded_plaintext = padding_length_bytes + plaintext + plaintext_padding

    return one_time_pad(padded_plaintext, key)



def otp_decrypt_with_padding(ciphertext: bytes, key: bytes) -> bytes:
    """
        Decrypts a one-time-pad ciphertext that has been padded

        Args:
            ciphertext: The padded ciphertext message to decrypt.
            key: The one-time pad. Must be at least as long as the ciphertext block.

        Returns:
            Plaintext as bytes.

    """

    plaintext_with_padding = one_time_pad(ciphertext, key)

    # Extract the plaintext length
    padding_length = int.from_bytes(plaintext_with_padding[:OTP_PADDING_LENGTH], "big") 
    
    # Return the plaintext without the padding nor padding length
    if padding_length != 0:
        return plaintext_with_padding[OTP_PADDING_LENGTH : -padding_length]

    # Return the plaintext without padding_length. Needed because 
    # if padding_length is 0, -padding_length would return an empty string

    return plaintext_with_padding[OTP_PADDING_LENGTH:]



def one_time_pad(plaintext: bytes, key: bytes) -> bytes:
    """
        Does one-time-pad XOR encryption on plaintext with key and returns result

        OTP is the only known encryption system that is mathematically proven to be unbreakable under the principles of information theory
        if the key is random and is never reused
    """
    otpd_plaintext = b''
    for index, plain_byte in enumerate(plaintext):
        key_byte = key[index]
        otpd_plaintext += bytes([plain_byte ^ key_byte])

    return otpd_plaintext



def generate_kem_keys(algorithm: str = "Kyber1024"):
    with oqs.KeyEncapsulation(algorithm) as kem:
        public_key = kem.generate_keypair()
        private_key = kem.export_secret_key()
        return private_key, public_key


def decrypt_kyber_shared_secrets(ciphertext_blob: bytes, private_key: bytes, otp_pad_size: int = 10240, algorithm: str = "Kyber1024"):
    """
        Decapsulates shared_secrets of size otp_pad_size and returns the resulting shared_secrets.
        The ciphertexts_blob is expected to be a concatenated sequence of Kyber ciphertexts,
        originally generated by generate_kyber_shared_secrets and sent by the contact.

        The shared_secrets are meant to be used as one-time-pads to decrypt received messages.

        Kyber1024 has a defined fixed-size ciphertext of 1568 bytes each, which allows us to safely
        split the blob and decapsulate in order.
    """

    shared_secrets = b''
    cipher_size = 1568  # Kyber1024 ciphertext size
    cursor = 0

    with oqs.KeyEncapsulation(algorithm, secret_key=private_key) as kem:
        while len(shared_secrets) < otp_pad_size:
            ciphertext = ciphertext_blob[cursor:cursor + cipher_size]

            if len(ciphertext) != cipher_size:
                raise ValueError("Ciphertext blob is malformed or incomplete")

            shared_secret = kem.decap_secret(ciphertext)
            shared_secrets += shared_secret
            cursor += cipher_size

    return shared_secrets[:otp_pad_size]

def generate_kyber_shared_secrets(public_key: bytes, otp_pad_size: int = 10240, algorithm: str = "Kyber1024"):
    """
        Generates shared_secrets of size otp_pad_size and returns both the ciphertext list-
        and the generated shared_secrets.
        The shared_secrets are meant to be used as one-time-pads to encypt our messages,
        while the ciphertext is meant to be sent to the contact.


        Default desired One-time-pad size is set to 10 kilobytes which is meant to accommodate-
        10 messages, assuming every message is 1024 bytes with the padding applies.


        We concatenate the ciphertexts together safely because Kyper1024 has a defined fixed-size ciphertext-
        of 1568 bytes each.
    """

    shared_secrets   = b''
    ciphertexts_blob = b''

    with oqs.KeyEncapsulation(algorithm) as kem:
        while len(shared_secrets) < otp_pad_size:
            ciphertext, shared_secret = kem.encap_secret(public_key)

            ciphertexts_blob += ciphertext
            shared_secrets   += shared_secret

    return ciphertexts_blob, shared_secrets[:otp_pad_size]


def randomize_replay_protection_number(replay_protection_number: int) -> int:
    return random_number_range(replay_protection_number, random_number_range(replay_protection_number + 1, replay_protection_number + random_number_range(100, 1000)))

def random_number_range(a: int, b: int) -> int:
    return secrets.randbelow(b - a + 1) + a

